<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/plugins/magnific-popup/jquery.magnific-popup.js - Engagement Lab Website</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Engagement Lab Website" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/about.html">about</a></li>
                                <li><a href="../classes/academics.html">academics</a></li>
                                <li><a href="../classes/category.html">category</a></li>
                                <li><a href="../classes/directory.html">directory</a></li>
                                <li><a href="../classes/EventEmitter Manages event registering and emitting..html">EventEmitter Manages event registering and emitting.</a></li>
                                <li><a href="../classes/index.html">index</a></li>
                                <li><a href="../classes/news.html">news</a></li>
                                <li><a href="../classes/program.html">program</a></li>
                                <li><a href="../classes/project.html">project</a></li>
                                <li><a href="../classes/routes.middleware.html">routes.middleware</a></li>
                                <li><a href="../classes/team.html">team</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/$.JQPlugin.html">$.JQPlugin</a></li>
                                <li><a href="../modules/about.html">about</a></li>
                                <li><a href="../modules/category.html">category</a></li>
                                <li><a href="../modules/program.html">program</a></li>
                                <li><a href="../modules/programs.html">programs</a></li>
                                <li><a href="../modules/project.html">project</a></li>
                                <li><a href="../modules/research.html">research</a></li>
                                <li><a href="../modules/resource.html">resource</a></li>
                                <li><a href="../modules/team.html">team</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: public/plugins/magnific-popup/jquery.magnific-popup.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! Magnific Popup - v1.0.0 - 2015-01-03
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2015 Dmitry Semenov; */
;(function (factory) { 
if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) { 
 // AMD. Register as an anonymous module. 
 define([&#x27;jquery&#x27;], factory); 
 } else if (typeof exports === &#x27;object&#x27;) { 
 // Node/CommonJS 
 factory(require(&#x27;jquery&#x27;)); 
 } else { 
 // Browser globals 
 factory(window.jQuery || window.Zepto); 
 } 
 }(function($) { 

/*&gt;&gt;core*/
/**
 * 
 * Magnific Popup Core JS file
 * 
 */


/**
 * Private static constants
 */
var CLOSE_EVENT = &#x27;Close&#x27;,
	BEFORE_CLOSE_EVENT = &#x27;BeforeClose&#x27;,
	AFTER_CLOSE_EVENT = &#x27;AfterClose&#x27;,
	BEFORE_APPEND_EVENT = &#x27;BeforeAppend&#x27;,
	MARKUP_PARSE_EVENT = &#x27;MarkupParse&#x27;,
	OPEN_EVENT = &#x27;Open&#x27;,
	CHANGE_EVENT = &#x27;Change&#x27;,
	NS = &#x27;mfp&#x27;,
	EVENT_NS = &#x27;.&#x27; + NS,
	READY_CLASS = &#x27;mfp-ready&#x27;,
	REMOVING_CLASS = &#x27;mfp-removing&#x27;,
	PREVENT_CLOSE_CLASS = &#x27;mfp-prevent-close&#x27;;


/**
 * Private vars 
 */
/*jshint -W079 */
var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use &#x27;this&#x27;
	MagnificPopup = function(){},
	_isJQ = !!(window.jQuery),
	_prevStatus,
	_window = $(window),
	_document,
	_prevContentType,
	_wrapClasses,
	_currPopupType;


/**
 * Private functions
 */
var _mfpOn = function(name, f) {
		mfp.ev.on(NS + name + EVENT_NS, f);
	},
	_getEl = function(className, appendTo, html, raw) {
		var el = document.createElement(&#x27;div&#x27;);
		el.className = &#x27;mfp-&#x27;+className;
		if(html) {
			el.innerHTML = html;
		}
		if(!raw) {
			el = $(el);
			if(appendTo) {
				el.appendTo(appendTo);
			}
		} else if(appendTo) {
			appendTo.appendChild(el);
		}
		return el;
	},
	_mfpTrigger = function(e, data) {
		mfp.ev.triggerHandler(NS + e, data);

		if(mfp.st.callbacks) {
			// converts &quot;mfpEventName&quot; to &quot;eventName&quot; callback and triggers it if it&#x27;s present
			e = e.charAt(0).toLowerCase() + e.slice(1);
			if(mfp.st.callbacks[e]) {
				mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
			}
		}
	},
	_getCloseBtn = function(type) {
		if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
			mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace(&#x27;%title%&#x27;, mfp.st.tClose ) );
			_currPopupType = type;
		}
		return mfp.currTemplate.closeBtn;
	},
	// Initialize Magnific Popup only when called at least once
	_checkInstance = function() {
		if(!$.magnificPopup.instance) {
			/*jshint -W020 */
			mfp = new MagnificPopup();
			mfp.init();
			$.magnificPopup.instance = mfp;
		}
	},
	// CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
	supportsTransitions = function() {
		var s = document.createElement(&#x27;p&#x27;).style, // &#x27;s&#x27; for style. better to create an element if body yet to exist
			v = [&#x27;ms&#x27;,&#x27;O&#x27;,&#x27;Moz&#x27;,&#x27;Webkit&#x27;]; // &#x27;v&#x27; for vendor

		if( s[&#x27;transition&#x27;] !== undefined ) {
			return true; 
		}
			
		while( v.length ) {
			if( v.pop() + &#x27;Transition&#x27; in s ) {
				return true;
			}
		}
				
		return false;
	};



/**
 * Public functions
 */
MagnificPopup.prototype = {

	constructor: MagnificPopup,

	/**
	 * Initializes Magnific Popup plugin. 
	 * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
	 */
	init: function() {
		var appVersion = navigator.appVersion;
		mfp.isIE7 = appVersion.indexOf(&quot;MSIE 7.&quot;) !== -1; 
		mfp.isIE8 = appVersion.indexOf(&quot;MSIE 8.&quot;) !== -1;
		mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
		mfp.isAndroid = (/android/gi).test(appVersion);
		mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
		mfp.supportsTransition = supportsTransitions();

		// We disable fixed positioned lightbox on devices that don&#x27;t handle it nicely.
		// If you know a better way of detecting this - let me know.
		mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
		_document = $(document);

		mfp.popupsCache = {};
	},

	/**
	 * Opens popup
	 * @param  data [description]
	 */
	open: function(data) {

		var i;

		if(data.isObj === false) { 
			// convert jQuery collection to array to avoid conflicts later
			mfp.items = data.items.toArray();

			mfp.index = 0;
			var items = data.items,
				item;
			for(i = 0; i &lt; items.length; i++) {
				item = items[i];
				if(item.parsed) {
					item = item.el[0];
				}
				if(item === data.el[0]) {
					mfp.index = i;
					break;
				}
			}
		} else {
			mfp.items = $.isArray(data.items) ? data.items : [data.items];
			mfp.index = data.index || 0;
		}

		// if popup is already opened - we just update the content
		if(mfp.isOpen) {
			mfp.updateItemHTML();
			return;
		}
		
		mfp.types = []; 
		_wrapClasses = &#x27;&#x27;;
		if(data.mainEl &amp;&amp; data.mainEl.length) {
			mfp.ev = data.mainEl.eq(0);
		} else {
			mfp.ev = _document;
		}

		if(data.key) {
			if(!mfp.popupsCache[data.key]) {
				mfp.popupsCache[data.key] = {};
			}
			mfp.currTemplate = mfp.popupsCache[data.key];
		} else {
			mfp.currTemplate = {};
		}



		mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); 
		mfp.fixedContentPos = mfp.st.fixedContentPos === &#x27;auto&#x27; ? !mfp.probablyMobile : mfp.st.fixedContentPos;

		if(mfp.st.modal) {
			mfp.st.closeOnContentClick = false;
			mfp.st.closeOnBgClick = false;
			mfp.st.showCloseBtn = false;
			mfp.st.enableEscapeKey = false;
		}
		

		// Building markup
		// main containers are created only once
		if(!mfp.bgOverlay) {

			// Dark overlay
			mfp.bgOverlay = _getEl(&#x27;bg&#x27;).on(&#x27;click&#x27;+EVENT_NS, function() {
				mfp.close();
			});

			mfp.wrap = _getEl(&#x27;wrap&#x27;).attr(&#x27;tabindex&#x27;, -1).on(&#x27;click&#x27;+EVENT_NS, function(e) {
				if(mfp._checkIfClose(e.target)) {
					mfp.close();
				}
			});

			mfp.container = _getEl(&#x27;container&#x27;, mfp.wrap);
		}

		mfp.contentContainer = _getEl(&#x27;content&#x27;);
		if(mfp.st.preloader) {
			mfp.preloader = _getEl(&#x27;preloader&#x27;, mfp.container, mfp.st.tLoading);
		}


		// Initializing modules
		var modules = $.magnificPopup.modules;
		for(i = 0; i &lt; modules.length; i++) {
			var n = modules[i];
			n = n.charAt(0).toUpperCase() + n.slice(1);
			mfp[&#x27;init&#x27;+n].call(mfp);
		}
		_mfpTrigger(&#x27;BeforeOpen&#x27;);


		if(mfp.st.showCloseBtn) {
			// Close button
			if(!mfp.st.closeBtnInside) {
				mfp.wrap.append( _getCloseBtn() );
			} else {
				_mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
					values.close_replaceWith = _getCloseBtn(item.type);
				});
				_wrapClasses += &#x27; mfp-close-btn-in&#x27;;
			}
		}

		if(mfp.st.alignTop) {
			_wrapClasses += &#x27; mfp-align-top&#x27;;
		}

	

		if(mfp.fixedContentPos) {
			mfp.wrap.css({
				overflow: mfp.st.overflowY,
				overflowX: &#x27;hidden&#x27;,
				overflowY: mfp.st.overflowY
			});
		} else {
			mfp.wrap.css({ 
				top: _window.scrollTop(),
				position: &#x27;absolute&#x27;
			});
		}
		if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === &#x27;auto&#x27; &amp;&amp; !mfp.fixedContentPos) ) {
			mfp.bgOverlay.css({
				height: _document.height(),
				position: &#x27;absolute&#x27;
			});
		}

		

		if(mfp.st.enableEscapeKey) {
			// Close on ESC key
			_document.on(&#x27;keyup&#x27; + EVENT_NS, function(e) {
				if(e.keyCode === 27) {
					mfp.close();
				}
			});
		}

		_window.on(&#x27;resize&#x27; + EVENT_NS, function() {
			mfp.updateSize();
		});


		if(!mfp.st.closeOnContentClick) {
			_wrapClasses += &#x27; mfp-auto-cursor&#x27;;
		}
		
		if(_wrapClasses)
			mfp.wrap.addClass(_wrapClasses);


		// this triggers recalculation of layout, so we get it once to not to trigger twice
		var windowHeight = mfp.wH = _window.height();

		
		var windowStyles = {};

		if( mfp.fixedContentPos ) {
            if(mfp._hasScrollBar(windowHeight)){
                var s = mfp._getScrollbarSize();
                if(s) {
                    windowStyles.marginRight = s;
                }
            }
        }

		if(mfp.fixedContentPos) {
			if(!mfp.isIE7) {
				windowStyles.overflow = &#x27;hidden&#x27;;
			} else {
				// ie7 double-scroll bug
				$(&#x27;body, html&#x27;).css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
			}
		}

		
		
		var classesToadd = mfp.st.mainClass;
		if(mfp.isIE7) {
			classesToadd += &#x27; mfp-ie7&#x27;;
		}
		if(classesToadd) {
			mfp._addClassToMFP( classesToadd );
		}

		// add content
		mfp.updateItemHTML();

		_mfpTrigger(&#x27;BuildControls&#x27;);

		// remove scrollbar, add margin e.t.c
		$(&#x27;html&#x27;).css(windowStyles);
		
		// add everything to DOM
		mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || $(document.body) );

		// Save last focused element
		mfp._lastFocusedEl = document.activeElement;
		
		// Wait for next cycle to allow CSS transition
		setTimeout(function() {
			
			if(mfp.content) {
				mfp._addClassToMFP(READY_CLASS);
				mfp._setFocus();
			} else {
				// if content is not defined (not loaded e.t.c) we add class only for BG
				mfp.bgOverlay.addClass(READY_CLASS);
			}
			
			// Trap the focus in popup
			_document.on(&#x27;focusin&#x27; + EVENT_NS, mfp._onFocusIn);

		}, 16);

		mfp.isOpen = true;
		mfp.updateSize(windowHeight);
		_mfpTrigger(OPEN_EVENT);

		return data;
	},

	/**
	 * Closes the popup
	 */
	close: function() {
		if(!mfp.isOpen) return;
		_mfpTrigger(BEFORE_CLOSE_EVENT);

		mfp.isOpen = false;
		// for CSS3 animation
		if(mfp.st.removalDelay &amp;&amp; !mfp.isLowIE &amp;&amp; mfp.supportsTransition )  {
			mfp._addClassToMFP(REMOVING_CLASS);
			setTimeout(function() {
				mfp._close();
			}, mfp.st.removalDelay);
		} else {
			mfp._close();
		}
	},

	/**
	 * Helper for close() function
	 */
	_close: function() {
		_mfpTrigger(CLOSE_EVENT);

		var classesToRemove = REMOVING_CLASS + &#x27; &#x27; + READY_CLASS + &#x27; &#x27;;

		mfp.bgOverlay.detach();
		mfp.wrap.detach();
		mfp.container.empty();

		if(mfp.st.mainClass) {
			classesToRemove += mfp.st.mainClass + &#x27; &#x27;;
		}

		mfp._removeClassFromMFP(classesToRemove);

		if(mfp.fixedContentPos) {
			var windowStyles = {marginRight: &#x27;&#x27;};
			if(mfp.isIE7) {
				$(&#x27;body, html&#x27;).css(&#x27;overflow&#x27;, &#x27;&#x27;);
			} else {
				windowStyles.overflow = &#x27;&#x27;;
			}
			$(&#x27;html&#x27;).css(windowStyles);
		}
		
		_document.off(&#x27;keyup&#x27; + EVENT_NS + &#x27; focusin&#x27; + EVENT_NS);
		mfp.ev.off(EVENT_NS);

		// clean up DOM elements that aren&#x27;t removed
		mfp.wrap.attr(&#x27;class&#x27;, &#x27;mfp-wrap&#x27;).removeAttr(&#x27;style&#x27;);
		mfp.bgOverlay.attr(&#x27;class&#x27;, &#x27;mfp-bg&#x27;);
		mfp.container.attr(&#x27;class&#x27;, &#x27;mfp-container&#x27;);

		// remove close button from target element
		if(mfp.st.showCloseBtn &amp;&amp;
		(!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
			if(mfp.currTemplate.closeBtn)
				mfp.currTemplate.closeBtn.detach();
		}


		if(mfp._lastFocusedEl) {
			$(mfp._lastFocusedEl).focus(); // put tab focus back
		}
		mfp.currItem = null;	
		mfp.content = null;
		mfp.currTemplate = null;
		mfp.prevHeight = 0;

		_mfpTrigger(AFTER_CLOSE_EVENT);
	},
	
	updateSize: function(winHeight) {

		if(mfp.isIOS) {
			// fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
			var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
			var height = window.innerHeight * zoomLevel;
			mfp.wrap.css(&#x27;height&#x27;, height);
			mfp.wH = height;
		} else {
			mfp.wH = winHeight || _window.height();
		}
		// Fixes #84: popup incorrectly positioned with position:relative on body
		if(!mfp.fixedContentPos) {
			mfp.wrap.css(&#x27;height&#x27;, mfp.wH);
		}

		_mfpTrigger(&#x27;Resize&#x27;);

	},

	/**
	 * Set content of popup based on current index
	 */
	updateItemHTML: function() {
		var item = mfp.items[mfp.index];

		// Detach and perform modifications
		mfp.contentContainer.detach();

		if(mfp.content)
			mfp.content.detach();

		if(!item.parsed) {
			item = mfp.parseEl( mfp.index );
		}

		var type = item.type;	

		_mfpTrigger(&#x27;BeforeChange&#x27;, [mfp.currItem ? mfp.currItem.type : &#x27;&#x27;, type]);
		// BeforeChange event works like so:
		// _mfpOn(&#x27;BeforeChange&#x27;, function(e, prevType, newType) { });
		
		mfp.currItem = item;

		

		

		if(!mfp.currTemplate[type]) {
			var markup = mfp.st[type] ? mfp.st[type].markup : false;

			// allows to modify markup
			_mfpTrigger(&#x27;FirstMarkupParse&#x27;, markup);

			if(markup) {
				mfp.currTemplate[type] = $(markup);
			} else {
				// if there is no markup found we just define that template is parsed
				mfp.currTemplate[type] = true;
			}
		}

		if(_prevContentType &amp;&amp; _prevContentType !== item.type) {
			mfp.container.removeClass(&#x27;mfp-&#x27;+_prevContentType+&#x27;-holder&#x27;);
		}
		
		var newContent = mfp[&#x27;get&#x27; + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
		mfp.appendContent(newContent, type);

		item.preloaded = true;

		_mfpTrigger(CHANGE_EVENT, item);
		_prevContentType = item.type;
		
		// Append container back after its content changed
		mfp.container.prepend(mfp.contentContainer);

		_mfpTrigger(&#x27;AfterChange&#x27;);
	},


	/**
	 * Set HTML content of popup
	 */
	appendContent: function(newContent, type) {
		mfp.content = newContent;
		
		if(newContent) {
			if(mfp.st.showCloseBtn &amp;&amp; mfp.st.closeBtnInside &amp;&amp;
				mfp.currTemplate[type] === true) {
				// if there is no markup, we just append close button element inside
				if(!mfp.content.find(&#x27;.mfp-close&#x27;).length) {
					mfp.content.append(_getCloseBtn());
				}
			} else {
				mfp.content = newContent;
			}
		} else {
			mfp.content = &#x27;&#x27;;
		}

		_mfpTrigger(BEFORE_APPEND_EVENT);
		mfp.container.addClass(&#x27;mfp-&#x27;+type+&#x27;-holder&#x27;);

		mfp.contentContainer.append(mfp.content);
	},



	
	/**
	 * Creates Magnific Popup data object based on given data
	 * @param  {int} index Index of item to parse
	 */
	parseEl: function(index) {
		var item = mfp.items[index],
			type;

		if(item.tagName) {
			item = { el: $(item) };
		} else {
			type = item.type;
			item = { data: item, src: item.src };
		}

		if(item.el) {
			var types = mfp.types;

			// check for &#x27;mfp-TYPE&#x27; class
			for(var i = 0; i &lt; types.length; i++) {
				if( item.el.hasClass(&#x27;mfp-&#x27;+types[i]) ) {
					type = types[i];
					break;
				}
			}

			item.src = item.el.attr(&#x27;data-mfp-src&#x27;);
			if(!item.src) {
				item.src = item.el.attr(&#x27;href&#x27;);
			}
		}

		item.type = type || mfp.st.type || &#x27;inline&#x27;;
		item.index = index;
		item.parsed = true;
		mfp.items[index] = item;
		_mfpTrigger(&#x27;ElementParse&#x27;, item);

		return mfp.items[index];
	},


	/**
	 * Initializes single popup or a group of popups
	 */
	addGroup: function(el, options) {
		var eHandler = function(e) {
			e.mfpEl = this;
			mfp._openClick(e, el, options);
		};

		if(!options) {
			options = {};
		} 

		var eName = &#x27;click.magnificPopup&#x27;;
		options.mainEl = el;
		
		if(options.items) {
			options.isObj = true;
			el.off(eName).on(eName, eHandler);
		} else {
			options.isObj = false;
			if(options.delegate) {
				el.off(eName).on(eName, options.delegate , eHandler);
			} else {
				options.items = el;
				el.off(eName).on(eName, eHandler);
			}
		}
	},
	_openClick: function(e, el, options) {
		var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


		if(!midClick &amp;&amp; ( e.which === 2 || e.ctrlKey || e.metaKey ) ) {
			return;
		}

		var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

		if(disableOn) {
			if($.isFunction(disableOn)) {
				if( !disableOn.call(mfp) ) {
					return true;
				}
			} else { // else it&#x27;s number
				if( _window.width() &lt; disableOn ) {
					return true;
				}
			}
		}
		
		if(e.type) {
			e.preventDefault();

			// This will prevent popup from closing if element is inside and popup is already opened
			if(mfp.isOpen) {
				e.stopPropagation();
			}
		}
			

		options.el = $(e.mfpEl);
		if(options.delegate) {
			options.items = el.find(options.delegate);
		}
		mfp.open(options);
	},


	/**
	 * Updates text on preloader
	 */
	updateStatus: function(status, text) {

		if(mfp.preloader) {
			if(_prevStatus !== status) {
				mfp.container.removeClass(&#x27;mfp-s-&#x27;+_prevStatus);
			}

			if(!text &amp;&amp; status === &#x27;loading&#x27;) {
				text = mfp.st.tLoading;
			}

			var data = {
				status: status,
				text: text
			};
			// allows to modify status
			_mfpTrigger(&#x27;UpdateStatus&#x27;, data);

			status = data.status;
			text = data.text;

			mfp.preloader.html(text);

			mfp.preloader.find(&#x27;a&#x27;).on(&#x27;click&#x27;, function(e) {
				e.stopImmediatePropagation();
			});

			mfp.container.addClass(&#x27;mfp-s-&#x27;+status);
			_prevStatus = status;
		}
	},


	/*
		&quot;Private&quot; helpers that aren&#x27;t private at all
	 */
	// Check to close popup or not
	// &quot;target&quot; is an element that was clicked
	_checkIfClose: function(target) {

		if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
			return;
		}

		var closeOnContent = mfp.st.closeOnContentClick;
		var closeOnBg = mfp.st.closeOnBgClick;

		if(closeOnContent &amp;&amp; closeOnBg) {
			return true;
		} else {

			// We close the popup if click is on close button or on preloader. Or if there is no content.
			if(!mfp.content || $(target).hasClass(&#x27;mfp-close&#x27;) || (mfp.preloader &amp;&amp; target === mfp.preloader[0]) ) {
				return true;
			}

			// if click is outside the content
			if(  (target !== mfp.content[0] &amp;&amp; !$.contains(mfp.content[0], target))  ) {
				if(closeOnBg) {
					// last check, if the clicked element is in DOM, (in case it&#x27;s removed onclick)
					if( $.contains(document, target) ) {
						return true;
					}
				}
			} else if(closeOnContent) {
				return true;
			}

		}
		return false;
	},
	_addClassToMFP: function(cName) {
		mfp.bgOverlay.addClass(cName);
		mfp.wrap.addClass(cName);
	},
	_removeClassFromMFP: function(cName) {
		this.bgOverlay.removeClass(cName);
		mfp.wrap.removeClass(cName);
	},
	_hasScrollBar: function(winHeight) {
		return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) &gt; (winHeight || _window.height()) );
	},
	_setFocus: function() {
		(mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
	},
	_onFocusIn: function(e) {
		if( e.target !== mfp.wrap[0] &amp;&amp; !$.contains(mfp.wrap[0], e.target) ) {
			mfp._setFocus();
			return false;
		}
	},
	_parseMarkup: function(template, values, item) {
		var arr;
		if(item.data) {
			values = $.extend(item.data, values);
		}
		_mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );

		$.each(values, function(key, value) {
			if(value === undefined || value === false) {
				return true;
			}
			arr = key.split(&#x27;_&#x27;);
			if(arr.length &gt; 1) {
				var el = template.find(EVENT_NS + &#x27;-&#x27;+arr[0]);

				if(el.length &gt; 0) {
					var attr = arr[1];
					if(attr === &#x27;replaceWith&#x27;) {
						if(el[0] !== value[0]) {
							el.replaceWith(value);
						}
					} else if(attr === &#x27;img&#x27;) {
						if(el.is(&#x27;img&#x27;)) {
							el.attr(&#x27;src&#x27;, value);
						} else {
							el.replaceWith( &#x27;&lt;img src=&quot;&#x27;+value+&#x27;&quot; class=&quot;&#x27; + el.attr(&#x27;class&#x27;) + &#x27;&quot; /&gt;&#x27; );
						}
					} else {
						el.attr(arr[1], value);
					}
				}

			} else {
				template.find(EVENT_NS + &#x27;-&#x27;+key).html(value);
			}
		});
	},

	_getScrollbarSize: function() {
		// thx David
		if(mfp.scrollbarSize === undefined) {
			var scrollDiv = document.createElement(&quot;div&quot;);
			scrollDiv.style.cssText = &#x27;width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;&#x27;;
			document.body.appendChild(scrollDiv);
			mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
			document.body.removeChild(scrollDiv);
		}
		return mfp.scrollbarSize;
	}

}; /* MagnificPopup core prototype end */




/**
 * Public static functions
 */
$.magnificPopup = {
	instance: null,
	proto: MagnificPopup.prototype,
	modules: [],

	open: function(options, index) {
		_checkInstance();	

		if(!options) {
			options = {};
		} else {
			options = $.extend(true, {}, options);
		}
			

		options.isObj = true;
		options.index = index || 0;
		return this.instance.open(options);
	},

	close: function() {
		return $.magnificPopup.instance &amp;&amp; $.magnificPopup.instance.close();
	},

	registerModule: function(name, module) {
		if(module.options) {
			$.magnificPopup.defaults[name] = module.options;
		}
		$.extend(this.proto, module.proto);			
		this.modules.push(name);
	},

	defaults: {   

		// Info about options is in docs:
		// http://dimsemenov.com/plugins/magnific-popup/documentation.html#options
		
		disableOn: 0,	

		key: null,

		midClick: false,

		mainClass: &#x27;&#x27;,

		preloader: true,

		focus: &#x27;&#x27;, // CSS selector of input to focus after popup is opened
		
		closeOnContentClick: false,

		closeOnBgClick: true,

		closeBtnInside: true, 

		showCloseBtn: true,

		enableEscapeKey: true,

		modal: false,

		alignTop: false,
	
		removalDelay: 0,

		prependTo: null,
		
		fixedContentPos: &#x27;auto&#x27;, 
	
		fixedBgPos: &#x27;auto&#x27;,

		overflowY: &#x27;auto&#x27;,

		closeMarkup: &#x27;&lt;button title=&quot;%title%&quot; type=&quot;button&quot; class=&quot;mfp-close&quot;&gt;&amp;times;&lt;/button&gt;&#x27;,

		tClose: &#x27;Close (Esc)&#x27;,

		tLoading: &#x27;Loading...&#x27;

	}
};



$.fn.magnificPopup = function(options) {
	_checkInstance();

	var jqEl = $(this);

	// We call some API method of first param is a string
	if (typeof options === &quot;string&quot; ) {

		if(options === &#x27;open&#x27;) {
			var items,
				itemOpts = _isJQ ? jqEl.data(&#x27;magnificPopup&#x27;) : jqEl[0].magnificPopup,
				index = parseInt(arguments[1], 10) || 0;

			if(itemOpts.items) {
				items = itemOpts.items[index];
			} else {
				items = jqEl;
				if(itemOpts.delegate) {
					items = items.find(itemOpts.delegate);
				}
				items = items.eq( index );
			}
			mfp._openClick({mfpEl:items}, jqEl, itemOpts);
		} else {
			if(mfp.isOpen)
				mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
		}

	} else {
		// clone options obj
		options = $.extend(true, {}, options);
		
		/*
		 * As Zepto doesn&#x27;t support .data() method for objects 
		 * and it works only in normal browsers
		 * we assign &quot;options&quot; object directly to the DOM element. FTW!
		 */
		if(_isJQ) {
			jqEl.data(&#x27;magnificPopup&#x27;, options);
		} else {
			jqEl[0].magnificPopup = options;
		}

		mfp.addGroup(jqEl, options);

	}
	return jqEl;
};


//Quick benchmark
/*
var start = performance.now(),
	i,
	rounds = 1000;

for(i = 0; i &lt; rounds; i++) {

}
console.log(&#x27;Test #1:&#x27;, performance.now() - start);

start = performance.now();
for(i = 0; i &lt; rounds; i++) {

}
console.log(&#x27;Test #2:&#x27;, performance.now() - start);
*/


/*&gt;&gt;core*/

/*&gt;&gt;inline*/

var INLINE_NS = &#x27;inline&#x27;,
	_hiddenClass,
	_inlinePlaceholder, 
	_lastInlineElement,
	_putInlineElementsBack = function() {
		if(_lastInlineElement) {
			_inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
			_lastInlineElement = null;
		}
	};

$.magnificPopup.registerModule(INLINE_NS, {
	options: {
		hiddenClass: &#x27;hide&#x27;, // will be appended with &#x60;mfp-&#x60; prefix
		markup: &#x27;&#x27;,
		tNotFound: &#x27;Content not found&#x27;
	},
	proto: {

		initInline: function() {
			mfp.types.push(INLINE_NS);

			_mfpOn(CLOSE_EVENT+&#x27;.&#x27;+INLINE_NS, function() {
				_putInlineElementsBack();
			});
		},

		getInline: function(item, template) {

			_putInlineElementsBack();

			if(item.src) {
				var inlineSt = mfp.st.inline,
					el = $(item.src);

				if(el.length) {

					// If target element has parent - we replace it with placeholder and put it back after popup is closed
					var parent = el[0].parentNode;
					if(parent &amp;&amp; parent.tagName) {
						if(!_inlinePlaceholder) {
							_hiddenClass = inlineSt.hiddenClass;
							_inlinePlaceholder = _getEl(_hiddenClass);
							_hiddenClass = &#x27;mfp-&#x27;+_hiddenClass;
						}
						// replace target inline element with placeholder
						_lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
					}

					mfp.updateStatus(&#x27;ready&#x27;);
				} else {
					mfp.updateStatus(&#x27;error&#x27;, inlineSt.tNotFound);
					el = $(&#x27;&lt;div&gt;&#x27;);
				}

				item.inlineElement = el;
				return el;
			}

			mfp.updateStatus(&#x27;ready&#x27;);
			mfp._parseMarkup(template, {}, item);
			return template;
		}
	}
});

/*&gt;&gt;inline*/

/*&gt;&gt;ajax*/
var AJAX_NS = &#x27;ajax&#x27;,
	_ajaxCur,
	_removeAjaxCursor = function() {
		if(_ajaxCur) {
			$(document.body).removeClass(_ajaxCur);
		}
	},
	_destroyAjaxRequest = function() {
		_removeAjaxCursor();
		if(mfp.req) {
			mfp.req.abort();
		}
	};

$.magnificPopup.registerModule(AJAX_NS, {

	options: {
		settings: null,
		cursor: &#x27;mfp-ajax-cur&#x27;,
		tError: &#x27;&lt;a href=&quot;%url%&quot;&gt;The content&lt;/a&gt; could not be loaded.&#x27;
	},

	proto: {
		initAjax: function() {
			mfp.types.push(AJAX_NS);
			_ajaxCur = mfp.st.ajax.cursor;

			_mfpOn(CLOSE_EVENT+&#x27;.&#x27;+AJAX_NS, _destroyAjaxRequest);
			_mfpOn(&#x27;BeforeChange.&#x27; + AJAX_NS, _destroyAjaxRequest);
		},
		getAjax: function(item) {

			if(_ajaxCur) {
				$(document.body).addClass(_ajaxCur);
			}

			mfp.updateStatus(&#x27;loading&#x27;);

			var opts = $.extend({
				url: item.src,
				success: function(data, textStatus, jqXHR) {
					var temp = {
						data:data,
						xhr:jqXHR
					};

					_mfpTrigger(&#x27;ParseAjax&#x27;, temp);

					mfp.appendContent( $(temp.data), AJAX_NS );

					item.finished = true;

					_removeAjaxCursor();

					mfp._setFocus();

					setTimeout(function() {
						mfp.wrap.addClass(READY_CLASS);
					}, 16);

					mfp.updateStatus(&#x27;ready&#x27;);

					_mfpTrigger(&#x27;AjaxContentAdded&#x27;);
				},
				error: function() {
					_removeAjaxCursor();
					item.finished = item.loadError = true;
					mfp.updateStatus(&#x27;error&#x27;, mfp.st.ajax.tError.replace(&#x27;%url%&#x27;, item.src));
				}
			}, mfp.st.ajax.settings);

			mfp.req = $.ajax(opts);

			return &#x27;&#x27;;
		}
	}
});





	

/*&gt;&gt;ajax*/

/*&gt;&gt;image*/
var _imgInterval,
	_getTitle = function(item) {
		if(item.data &amp;&amp; item.data.title !== undefined) 
			return item.data.title;

		var src = mfp.st.image.titleSrc;

		if(src) {
			if($.isFunction(src)) {
				return src.call(mfp, item);
			} else if(item.el) {
				return item.el.attr(src) || &#x27;&#x27;;
			}
		}
		return &#x27;&#x27;;
	};

$.magnificPopup.registerModule(&#x27;image&#x27;, {

	options: {
		markup: &#x27;&lt;div class=&quot;mfp-figure&quot;&gt;&#x27;+
					&#x27;&lt;div class=&quot;mfp-close&quot;&gt;&lt;/div&gt;&#x27;+
					&#x27;&lt;figure&gt;&#x27;+
						&#x27;&lt;div class=&quot;mfp-img&quot;&gt;&lt;/div&gt;&#x27;+
						&#x27;&lt;figcaption&gt;&#x27;+
							&#x27;&lt;div class=&quot;mfp-bottom-bar&quot;&gt;&#x27;+
								&#x27;&lt;div class=&quot;mfp-title&quot;&gt;&lt;/div&gt;&#x27;+
								&#x27;&lt;div class=&quot;mfp-counter&quot;&gt;&lt;/div&gt;&#x27;+
							&#x27;&lt;/div&gt;&#x27;+
						&#x27;&lt;/figcaption&gt;&#x27;+
					&#x27;&lt;/figure&gt;&#x27;+
				&#x27;&lt;/div&gt;&#x27;,
		cursor: &#x27;mfp-zoom-out-cur&#x27;,
		titleSrc: &#x27;title&#x27;, 
		verticalFit: true,
		tError: &#x27;&lt;a href=&quot;%url%&quot;&gt;The image&lt;/a&gt; could not be loaded.&#x27;
	},

	proto: {
		initImage: function() {
			var imgSt = mfp.st.image,
				ns = &#x27;.image&#x27;;

			mfp.types.push(&#x27;image&#x27;);

			_mfpOn(OPEN_EVENT+ns, function() {
				if(mfp.currItem.type === &#x27;image&#x27; &amp;&amp; imgSt.cursor) {
					$(document.body).addClass(imgSt.cursor);
				}
			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(imgSt.cursor) {
					$(document.body).removeClass(imgSt.cursor);
				}
				_window.off(&#x27;resize&#x27; + EVENT_NS);
			});

			_mfpOn(&#x27;Resize&#x27;+ns, mfp.resizeImage);
			if(mfp.isLowIE) {
				_mfpOn(&#x27;AfterChange&#x27;, mfp.resizeImage);
			}
		},
		resizeImage: function() {
			var item = mfp.currItem;
			if(!item || !item.img) return;

			if(mfp.st.image.verticalFit) {
				var decr = 0;
				// fix box-sizing in ie7/8
				if(mfp.isLowIE) {
					decr = parseInt(item.img.css(&#x27;padding-top&#x27;), 10) + parseInt(item.img.css(&#x27;padding-bottom&#x27;),10);
				}
				item.img.css(&#x27;max-height&#x27;, mfp.wH-decr);
			}
		},
		_onImageHasSize: function(item) {
			if(item.img) {
				
				item.hasSize = true;

				if(_imgInterval) {
					clearInterval(_imgInterval);
				}
				
				item.isCheckingImgSize = false;

				_mfpTrigger(&#x27;ImageHasSize&#x27;, item);

				if(item.imgHidden) {
					if(mfp.content)
						mfp.content.removeClass(&#x27;mfp-loading&#x27;);
					
					item.imgHidden = false;
				}

			}
		},

		/**
		 * Function that loops until the image has size to display elements that rely on it asap
		 */
		findImageSize: function(item) {

			var counter = 0,
				img = item.img[0],
				mfpSetInterval = function(delay) {

					if(_imgInterval) {
						clearInterval(_imgInterval);
					}
					// decelerating interval that checks for size of an image
					_imgInterval = setInterval(function() {
						if(img.naturalWidth &gt; 0) {
							mfp._onImageHasSize(item);
							return;
						}

						if(counter &gt; 200) {
							clearInterval(_imgInterval);
						}

						counter++;
						if(counter === 3) {
							mfpSetInterval(10);
						} else if(counter === 40) {
							mfpSetInterval(50);
						} else if(counter === 100) {
							mfpSetInterval(500);
						}
					}, delay);
				};

			mfpSetInterval(1);
		},

		getImage: function(item, template) {

			var guard = 0,

				// image load complete handler
				onLoadComplete = function() {
					if(item) {
						if (item.img[0].complete) {
							item.img.off(&#x27;.mfploader&#x27;);
							
							if(item === mfp.currItem){
								mfp._onImageHasSize(item);

								mfp.updateStatus(&#x27;ready&#x27;);
							}

							item.hasSize = true;
							item.loaded = true;

							_mfpTrigger(&#x27;ImageLoadComplete&#x27;);
							
						}
						else {
							// if image complete check fails 200 times (20 sec), we assume that there was an error.
							guard++;
							if(guard &lt; 200) {
								setTimeout(onLoadComplete,100);
							} else {
								onLoadError();
							}
						}
					}
				},

				// image error handler
				onLoadError = function() {
					if(item) {
						item.img.off(&#x27;.mfploader&#x27;);
						if(item === mfp.currItem){
							mfp._onImageHasSize(item);
							mfp.updateStatus(&#x27;error&#x27;, imgSt.tError.replace(&#x27;%url%&#x27;, item.src) );
						}

						item.hasSize = true;
						item.loaded = true;
						item.loadError = true;
					}
				},
				imgSt = mfp.st.image;


			var el = template.find(&#x27;.mfp-img&#x27;);
			if(el.length) {
				var img = document.createElement(&#x27;img&#x27;);
				img.className = &#x27;mfp-img&#x27;;
				if(item.el &amp;&amp; item.el.find(&#x27;img&#x27;).length) {
					img.alt = item.el.find(&#x27;img&#x27;).attr(&#x27;alt&#x27;);
				}
				item.img = $(img).on(&#x27;load.mfploader&#x27;, onLoadComplete).on(&#x27;error.mfploader&#x27;, onLoadError);
				img.src = item.src;

				// without clone() &quot;error&quot; event is not firing when IMG is replaced by new IMG
				// TODO: find a way to avoid such cloning
				if(el.is(&#x27;img&#x27;)) {
					item.img = item.img.clone();
				}

				img = item.img[0];
				if(img.naturalWidth &gt; 0) {
					item.hasSize = true;
				} else if(!img.width) {										
					item.hasSize = false;
				}
			}

			mfp._parseMarkup(template, {
				title: _getTitle(item),
				img_replaceWith: item.img
			}, item);

			mfp.resizeImage();

			if(item.hasSize) {
				if(_imgInterval) clearInterval(_imgInterval);

				if(item.loadError) {
					template.addClass(&#x27;mfp-loading&#x27;);
					mfp.updateStatus(&#x27;error&#x27;, imgSt.tError.replace(&#x27;%url%&#x27;, item.src) );
				} else {
					template.removeClass(&#x27;mfp-loading&#x27;);
					mfp.updateStatus(&#x27;ready&#x27;);
				}
				return template;
			}

			mfp.updateStatus(&#x27;loading&#x27;);
			item.loading = true;

			if(!item.hasSize) {
				item.imgHidden = true;
				template.addClass(&#x27;mfp-loading&#x27;);
				mfp.findImageSize(item);
			} 

			return template;
		}
	}
});



/*&gt;&gt;image*/

/*&gt;&gt;zoom*/
var hasMozTransform,
	getHasMozTransform = function() {
		if(hasMozTransform === undefined) {
			hasMozTransform = document.createElement(&#x27;p&#x27;).style.MozTransform !== undefined;
		}
		return hasMozTransform;		
	};

$.magnificPopup.registerModule(&#x27;zoom&#x27;, {

	options: {
		enabled: false,
		easing: &#x27;ease-in-out&#x27;,
		duration: 300,
		opener: function(element) {
			return element.is(&#x27;img&#x27;) ? element : element.find(&#x27;img&#x27;);
		}
	},

	proto: {

		initZoom: function() {
			var zoomSt = mfp.st.zoom,
				ns = &#x27;.zoom&#x27;,
				image;
				
			if(!zoomSt.enabled || !mfp.supportsTransition) {
				return;
			}

			var duration = zoomSt.duration,
				getElToAnimate = function(image) {
					var newImg = image.clone().removeAttr(&#x27;style&#x27;).removeAttr(&#x27;class&#x27;).addClass(&#x27;mfp-animated-image&#x27;),
						transition = &#x27;all &#x27;+(zoomSt.duration/1000)+&#x27;s &#x27; + zoomSt.easing,
						cssObj = {
							position: &#x27;fixed&#x27;,
							zIndex: 9999,
							left: 0,
							top: 0,
							&#x27;-webkit-backface-visibility&#x27;: &#x27;hidden&#x27;
						},
						t = &#x27;transition&#x27;;

					cssObj[&#x27;-webkit-&#x27;+t] = cssObj[&#x27;-moz-&#x27;+t] = cssObj[&#x27;-o-&#x27;+t] = cssObj[t] = transition;

					newImg.css(cssObj);
					return newImg;
				},
				showMainContent = function() {
					mfp.content.css(&#x27;visibility&#x27;, &#x27;visible&#x27;);
				},
				openTimeout,
				animatedImg;

			_mfpOn(&#x27;BuildControls&#x27;+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);
					mfp.content.css(&#x27;visibility&#x27;, &#x27;hidden&#x27;);

					// Basically, all code below does is clones existing image, puts in on top of the current one and animated it
					
					image = mfp._getItemToZoom();

					if(!image) {
						showMainContent();
						return;
					}

					animatedImg = getElToAnimate(image); 
					
					animatedImg.css( mfp._getOffset() );

					mfp.wrap.append(animatedImg);

					openTimeout = setTimeout(function() {
						animatedImg.css( mfp._getOffset( true ) );
						openTimeout = setTimeout(function() {

							showMainContent();

							setTimeout(function() {
								animatedImg.remove();
								image = animatedImg = null;
								_mfpTrigger(&#x27;ZoomAnimationEnded&#x27;);
							}, 16); // avoid blink when switching images 

						}, duration); // this timeout equals animation duration

					}, 16); // by adding this timeout we avoid short glitch at the beginning of animation


					// Lots of timeouts...
				}
			});
			_mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);

					mfp.st.removalDelay = duration;

					if(!image) {
						image = mfp._getItemToZoom();
						if(!image) {
							return;
						}
						animatedImg = getElToAnimate(image);
					}
					
					
					animatedImg.css( mfp._getOffset(true) );
					mfp.wrap.append(animatedImg);
					mfp.content.css(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
					
					setTimeout(function() {
						animatedImg.css( mfp._getOffset() );
					}, 16);
				}

			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {
					showMainContent();
					if(animatedImg) {
						animatedImg.remove();
					}
					image = null;
				}	
			});
		},

		_allowZoom: function() {
			return mfp.currItem.type === &#x27;image&#x27;;
		},

		_getItemToZoom: function() {
			if(mfp.currItem.hasSize) {
				return mfp.currItem.img;
			} else {
				return false;
			}
		},

		// Get element postion relative to viewport
		_getOffset: function(isLarge) {
			var el;
			if(isLarge) {
				el = mfp.currItem.img;
			} else {
				el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
			}

			var offset = el.offset();
			var paddingTop = parseInt(el.css(&#x27;padding-top&#x27;),10);
			var paddingBottom = parseInt(el.css(&#x27;padding-bottom&#x27;),10);
			offset.top -= ( $(window).scrollTop() - paddingTop );


			/*
			
			Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

			 */
			var obj = {
				width: el.width(),
				// fix Zepto height+padding issue
				height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
			};

			// I hate to do this, but there is no another option
			if( getHasMozTransform() ) {
				obj[&#x27;-moz-transform&#x27;] = obj[&#x27;transform&#x27;] = &#x27;translate(&#x27; + offset.left + &#x27;px,&#x27; + offset.top + &#x27;px)&#x27;;
			} else {
				obj.left = offset.left;
				obj.top = offset.top;
			}
			return obj;
		}

	}
});



/*&gt;&gt;zoom*/

/*&gt;&gt;iframe*/

var IFRAME_NS = &#x27;iframe&#x27;,
	_emptyPage = &#x27;//about:blank&#x27;,
	
	_fixIframeBugs = function(isShowing) {
		if(mfp.currTemplate[IFRAME_NS]) {
			var el = mfp.currTemplate[IFRAME_NS].find(&#x27;iframe&#x27;);
			if(el.length) { 
				// reset src after the popup is closed to avoid &quot;video keeps playing after popup is closed&quot; bug
				if(!isShowing) {
					el[0].src = _emptyPage;
				}

				// IE8 black screen bug fix
				if(mfp.isIE8) {
					el.css(&#x27;display&#x27;, isShowing ? &#x27;block&#x27; : &#x27;none&#x27;);
				}
			}
		}
	};

$.magnificPopup.registerModule(IFRAME_NS, {

	options: {
		markup: &#x27;&lt;div class=&quot;mfp-iframe-scaler&quot;&gt;&#x27;+
					&#x27;&lt;div class=&quot;mfp-close&quot;&gt;&lt;/div&gt;&#x27;+
					&#x27;&lt;iframe class=&quot;mfp-iframe&quot; src=&quot;//about:blank&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&#x27;+
				&#x27;&lt;/div&gt;&#x27;,

		srcAction: &#x27;iframe_src&#x27;,

		// we don&#x27;t care and support only one default type of URL by default
		patterns: {
			youtube: {
				index: &#x27;youtube.com&#x27;, 
				id: &#x27;v=&#x27;, 
				src: &#x27;//www.youtube.com/embed/%id%?autoplay=1&#x27;
			},
			vimeo: {
				index: &#x27;vimeo.com/&#x27;,
				id: &#x27;/&#x27;,
				src: &#x27;//player.vimeo.com/video/%id%?autoplay=1&#x27;
			},
			gmaps: {
				index: &#x27;//maps.google.&#x27;,
				src: &#x27;%id%&amp;output=embed&#x27;
			}
		}
	},

	proto: {
		initIframe: function() {
			mfp.types.push(IFRAME_NS);

			_mfpOn(&#x27;BeforeChange&#x27;, function(e, prevType, newType) {
				if(prevType !== newType) {
					if(prevType === IFRAME_NS) {
						_fixIframeBugs(); // iframe if removed
					} else if(newType === IFRAME_NS) {
						_fixIframeBugs(true); // iframe is showing
					} 
				}// else {
					// iframe source is switched, don&#x27;t do anything
				//}
			});

			_mfpOn(CLOSE_EVENT + &#x27;.&#x27; + IFRAME_NS, function() {
				_fixIframeBugs();
			});
		},

		getIframe: function(item, template) {
			var embedSrc = item.src;
			var iframeSt = mfp.st.iframe;
				
			$.each(iframeSt.patterns, function() {
				if(embedSrc.indexOf( this.index ) &gt; -1) {
					if(this.id) {
						if(typeof this.id === &#x27;string&#x27;) {
							embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
						} else {
							embedSrc = this.id.call( this, embedSrc );
						}
					}
					embedSrc = this.src.replace(&#x27;%id%&#x27;, embedSrc );
					return false; // break;
				}
			});
			
			var dataObj = {};
			if(iframeSt.srcAction) {
				dataObj[iframeSt.srcAction] = embedSrc;
			}
			mfp._parseMarkup(template, dataObj, item);

			mfp.updateStatus(&#x27;ready&#x27;);

			return template;
		}
	}
});



/*&gt;&gt;iframe*/

/*&gt;&gt;gallery*/
/**
 * Get looped index depending on number of slides
 */
var _getLoopedId = function(index) {
		var numSlides = mfp.items.length;
		if(index &gt; numSlides - 1) {
			return index - numSlides;
		} else  if(index &lt; 0) {
			return numSlides + index;
		}
		return index;
	},
	_replaceCurrTotal = function(text, curr, total) {
		return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
	};

$.magnificPopup.registerModule(&#x27;gallery&#x27;, {

	options: {
		enabled: false,
		arrowMarkup: &#x27;&lt;button title=&quot;%title%&quot; type=&quot;button&quot; class=&quot;mfp-arrow mfp-arrow-%dir%&quot;&gt;&lt;/button&gt;&#x27;,
		preload: [0,2],
		navigateByImgClick: true,
		arrows: true,

		tPrev: &#x27;Previous (Left arrow key)&#x27;,
		tNext: &#x27;Next (Right arrow key)&#x27;,
		tCounter: &#x27;%curr% of %total%&#x27;
	},

	proto: {
		initGallery: function() {

			var gSt = mfp.st.gallery,
				ns = &#x27;.mfp-gallery&#x27;,
				supportsFastClick = Boolean($.fn.mfpFastClick);

			mfp.direction = true; // true - next, false - prev
			
			if(!gSt || !gSt.enabled ) return false;

			_wrapClasses += &#x27; mfp-gallery&#x27;;

			_mfpOn(OPEN_EVENT+ns, function() {

				if(gSt.navigateByImgClick) {
					mfp.wrap.on(&#x27;click&#x27;+ns, &#x27;.mfp-img&#x27;, function() {
						if(mfp.items.length &gt; 1) {
							mfp.next();
							return false;
						}
					});
				}

				_document.on(&#x27;keydown&#x27;+ns, function(e) {
					if (e.keyCode === 37) {
						mfp.prev();
					} else if (e.keyCode === 39) {
						mfp.next();
					}
				});
			});

			_mfpOn(&#x27;UpdateStatus&#x27;+ns, function(e, data) {
				if(data.text) {
					data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
				}
			});

			_mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
				var l = mfp.items.length;
				values.counter = l &gt; 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : &#x27;&#x27;;
			});

			_mfpOn(&#x27;BuildControls&#x27; + ns, function() {
				if(mfp.items.length &gt; 1 &amp;&amp; gSt.arrows &amp;&amp; !mfp.arrowLeft) {
					var markup = gSt.arrowMarkup,
						arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, &#x27;left&#x27;) ).addClass(PREVENT_CLOSE_CLASS),			
						arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, &#x27;right&#x27;) ).addClass(PREVENT_CLOSE_CLASS);

					var eName = supportsFastClick ? &#x27;mfpFastClick&#x27; : &#x27;click&#x27;;
					arrowLeft[eName](function() {
						mfp.prev();
					});			
					arrowRight[eName](function() {
						mfp.next();
					});	

					// Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
					if(mfp.isIE7) {
						_getEl(&#x27;b&#x27;, arrowLeft[0], false, true);
						_getEl(&#x27;a&#x27;, arrowLeft[0], false, true);
						_getEl(&#x27;b&#x27;, arrowRight[0], false, true);
						_getEl(&#x27;a&#x27;, arrowRight[0], false, true);
					}

					mfp.container.append(arrowLeft.add(arrowRight));
				}
			});

			_mfpOn(CHANGE_EVENT+ns, function() {
				if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

				mfp._preloadTimeout = setTimeout(function() {
					mfp.preloadNearbyImages();
					mfp._preloadTimeout = null;
				}, 16);		
			});


			_mfpOn(CLOSE_EVENT+ns, function() {
				_document.off(ns);
				mfp.wrap.off(&#x27;click&#x27;+ns);
			
				if(mfp.arrowLeft &amp;&amp; supportsFastClick) {
					mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
				}
				mfp.arrowRight = mfp.arrowLeft = null;
			});

		}, 
		next: function() {
			mfp.direction = true;
			mfp.index = _getLoopedId(mfp.index + 1);
			mfp.updateItemHTML();
		},
		prev: function() {
			mfp.direction = false;
			mfp.index = _getLoopedId(mfp.index - 1);
			mfp.updateItemHTML();
		},
		goTo: function(newIndex) {
			mfp.direction = (newIndex &gt;= mfp.index);
			mfp.index = newIndex;
			mfp.updateItemHTML();
		},
		preloadNearbyImages: function() {
			var p = mfp.st.gallery.preload,
				preloadBefore = Math.min(p[0], mfp.items.length),
				preloadAfter = Math.min(p[1], mfp.items.length),
				i;

			for(i = 1; i &lt;= (mfp.direction ? preloadAfter : preloadBefore); i++) {
				mfp._preloadItem(mfp.index+i);
			}
			for(i = 1; i &lt;= (mfp.direction ? preloadBefore : preloadAfter); i++) {
				mfp._preloadItem(mfp.index-i);
			}
		},
		_preloadItem: function(index) {
			index = _getLoopedId(index);

			if(mfp.items[index].preloaded) {
				return;
			}

			var item = mfp.items[index];
			if(!item.parsed) {
				item = mfp.parseEl( index );
			}

			_mfpTrigger(&#x27;LazyLoad&#x27;, item);

			if(item.type === &#x27;image&#x27;) {
				item.img = $(&#x27;&lt;img class=&quot;mfp-img&quot; /&gt;&#x27;).on(&#x27;load.mfploader&#x27;, function() {
					item.hasSize = true;
				}).on(&#x27;error.mfploader&#x27;, function() {
					item.hasSize = true;
					item.loadError = true;
					_mfpTrigger(&#x27;LazyLoadError&#x27;, item);
				}).attr(&#x27;src&#x27;, item.src);
			}


			item.preloaded = true;
		}
	}
});

/*
Touch Support that might be implemented some day

addSwipeGesture: function() {
	var startX,
		moved,
		multipleTouches;

		return;

	var namespace = &#x27;.mfp&#x27;,
		addEventNames = function(pref, down, move, up, cancel) {
			mfp._tStart = pref + down + namespace;
			mfp._tMove = pref + move + namespace;
			mfp._tEnd = pref + up + namespace;
			mfp._tCancel = pref + cancel + namespace;
		};

	if(window.navigator.msPointerEnabled) {
		addEventNames(&#x27;MSPointer&#x27;, &#x27;Down&#x27;, &#x27;Move&#x27;, &#x27;Up&#x27;, &#x27;Cancel&#x27;);
	} else if(&#x27;ontouchstart&#x27; in window) {
		addEventNames(&#x27;touch&#x27;, &#x27;start&#x27;, &#x27;move&#x27;, &#x27;end&#x27;, &#x27;cancel&#x27;);
	} else {
		return;
	}
	_window.on(mfp._tStart, function(e) {
		var oE = e.originalEvent;
		multipleTouches = moved = false;
		startX = oE.pageX || oE.changedTouches[0].pageX;
	}).on(mfp._tMove, function(e) {
		if(e.originalEvent.touches.length &gt; 1) {
			multipleTouches = e.originalEvent.touches.length;
		} else {
			//e.preventDefault();
			moved = true;
		}
	}).on(mfp._tEnd + &#x27; &#x27; + mfp._tCancel, function(e) {
		if(moved &amp;&amp; !multipleTouches) {
			var oE = e.originalEvent,
				diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

			if(diff &gt; 20) {
				mfp.next();
			} else if(diff &lt; -20) {
				mfp.prev();
			}
		}
	});
},
*/


/*&gt;&gt;gallery*/

/*&gt;&gt;retina*/

var RETINA_NS = &#x27;retina&#x27;;

$.magnificPopup.registerModule(RETINA_NS, {
	options: {
		replaceSrc: function(item) {
			return item.src.replace(/\.\w+$/, function(m) { return &#x27;@2x&#x27; + m; });
		},
		ratio: 1 // Function or number.  Set to 1 to disable.
	},
	proto: {
		initRetina: function() {
			if(window.devicePixelRatio &gt; 1) {

				var st = mfp.st.retina,
					ratio = st.ratio;

				ratio = !isNaN(ratio) ? ratio : ratio();

				if(ratio &gt; 1) {
					_mfpOn(&#x27;ImageHasSize&#x27; + &#x27;.&#x27; + RETINA_NS, function(e, item) {
						item.img.css({
							&#x27;max-width&#x27;: item.img[0].naturalWidth / ratio,
							&#x27;width&#x27;: &#x27;100%&#x27;
						});
					});
					_mfpOn(&#x27;ElementParse&#x27; + &#x27;.&#x27; + RETINA_NS, function(e, item) {
						item.src = st.replaceSrc(item, ratio);
					});
				}
			}

		}
	}
});

/*&gt;&gt;retina*/

/*&gt;&gt;fastclick*/
/**
 * FastClick event implementation. (removes 300ms delay on touch devices)
 * Based on https://developers.google.com/mobile/articles/fast_buttons
 *
 * You may use it outside the Magnific Popup by calling just:
 *
 * $(&#x27;.your-el&#x27;).mfpFastClick(function() {
 *     console.log(&#x27;Clicked!&#x27;);
 * });
 *
 * To unbind:
 * $(&#x27;.your-el&#x27;).destroyMfpFastClick();
 * 
 * 
 * Note that it&#x27;s a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
 * If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
 * 
 */

(function() {
	var ghostClickDelay = 1000,
		supportsTouch = &#x27;ontouchstart&#x27; in window,
		unbindTouchMove = function() {
			_window.off(&#x27;touchmove&#x27;+ns+&#x27; touchend&#x27;+ns);
		},
		eName = &#x27;mfpFastClick&#x27;,
		ns = &#x27;.&#x27;+eName;


	// As Zepto.js doesn&#x27;t have an easy way to add custom events (like jQuery), so we implement it in this way
	$.fn.mfpFastClick = function(callback) {

		return $(this).each(function() {

			var elem = $(this),
				lock;

			if( supportsTouch ) {

				var timeout,
					startX,
					startY,
					pointerMoved,
					point,
					numPointers;

				elem.on(&#x27;touchstart&#x27; + ns, function(e) {
					pointerMoved = false;
					numPointers = 1;

					point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
					startX = point.clientX;
					startY = point.clientY;

					_window.on(&#x27;touchmove&#x27;+ns, function(e) {
						point = e.originalEvent ? e.originalEvent.touches : e.touches;
						numPointers = point.length;
						point = point[0];
						if (Math.abs(point.clientX - startX) &gt; 10 ||
							Math.abs(point.clientY - startY) &gt; 10) {
							pointerMoved = true;
							unbindTouchMove();
						}
					}).on(&#x27;touchend&#x27;+ns, function(e) {
						unbindTouchMove();
						if(pointerMoved || numPointers &gt; 1) {
							return;
						}
						lock = true;
						e.preventDefault();
						clearTimeout(timeout);
						timeout = setTimeout(function() {
							lock = false;
						}, ghostClickDelay);
						callback();
					});
				});

			}

			elem.on(&#x27;click&#x27; + ns, function() {
				if(!lock) {
					callback();
				}
			});
		});
	};

	$.fn.destroyMfpFastClick = function() {
		$(this).off(&#x27;touchstart&#x27; + ns + &#x27; click&#x27; + ns);
		if(supportsTouch) _window.off(&#x27;touchmove&#x27;+ns+&#x27; touchend&#x27;+ns);
	};
})();

/*&gt;&gt;fastclick*/
 _checkInstance(); }));
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
